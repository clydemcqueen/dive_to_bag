#!/usr/bin/env python3

"""
Read the csv files generated by wl_ugps_external_extension and create a bag with sensor data and transforms.

Coordinate frames and transform tree:
    map -- world frame, origin is the 1st GGA message
        vessel -- pose of the GNSS compass, from GGA and HDT logs
            antenna -- pose of the WL UGPS antenna (not provided by this script)
                acoustic -- pose of the ROV, from g2_acoustic log

You must provide a static transform vessel -> antenna, e.g.,
    ros2 run tf2_ros static_transform_publisher 1.57 -1.273 -0.377 0 0 0 vessel antenna

You can install python3-transforms3d from apt.
"""

import argparse
import csv
import math

import geometry_msgs.msg
import rosbag2_py
import transforms3d

import util


# TODO PASHR replaces HDT
# TODO write GGA as NavSatFix, but for the sat_compass
# TODO add --out parameter
# TODO add --gps0, default None, idea is that caller will pass the same --gps0 to several scripts


class State:
    def __init__(self, writer: rosbag2_py.SequentialWriter, acoustic_bias: tuple[float, ...]):
        self.writer = writer
        self.acoustic_bias = acoustic_bias

        # The initial vessel GPS reading will define (0, 0) in the map frame
        self.gps0: tuple[float, float] | None = None

        # Outputs
        self.tf_map_vessel = geometry_msgs.msg.TransformStamped()
        self.tf_map_vessel.header.frame_id = 'map'
        self.tf_map_vessel.child_frame_id = 'vessel'

        self.tf_antenna_acoustic = geometry_msgs.msg.TransformStamped()
        self.tf_antenna_acoustic.header.frame_id = 'antenna'
        self.tf_antenna_acoustic.child_frame_id = 'acoustic'

        self.num_transforms = 0

    def recv_gga(self, row):
        """
        Update the map -> vessel translation. Wait for the HDT message to write the transform to the bag.
        """
        gps = (float(row['latitude']), float(row['longitude']))

        if self.gps0 is None:
            # First GPS message defines the origin of the map frame
            self.gps0 = gps
            print(f'First GPS reading defines the map frame: --lat0 {self.gps0[0]} --lon0 {self.gps0[1]}')
        else:
            # Vessel position (x, y) in the map frame
            vessel_f_map = util.haversine_enu(self.gps0, gps)

            self.tf_map_vessel.transform.translation.x = vessel_f_map[0]
            self.tf_map_vessel.transform.translation.y = vessel_f_map[1]

    def recv_acoustic(self, row):
        """
        Update the antenna -> acoustic transform, and write it to the bag.
        """
        util.time_s_to_ros(float(row['timestamp']), self.tf_antenna_acoustic.header.stamp)

        # Convert NED->ENU
        self.tf_antenna_acoustic.transform.translation.x = float(row['y']) - self.acoustic_bias[1]
        self.tf_antenna_acoustic.transform.translation.y = float(row['x']) - self.acoustic_bias[0]
        self.tf_antenna_acoustic.transform.translation.z = -(float(row['z']) - self.acoustic_bias[2])

        util.write_transform_message(self.writer, self.tf_antenna_acoustic)
        self.num_transforms += 1

    def recv_hdt(self, row):
        """
        Update the map -> vessel rotation, and write the transform to the bag.
        """
        util.time_s_to_ros(float(row['timestamp']), self.tf_map_vessel.header.stamp)

        # Convert NED->ENU
        heading = -math.radians(float(row['heading']))
        vessel_orientation = transforms3d.euler.euler2quat(0, 0, heading)

        # transforms3d quaternion is [w, x, y, z]
        self.tf_map_vessel.transform.rotation.w = vessel_orientation[0]
        self.tf_map_vessel.transform.rotation.x = vessel_orientation[1]
        self.tf_map_vessel.transform.rotation.y = vessel_orientation[2]
        self.tf_map_vessel.transform.rotation.z = vessel_orientation[3]

        util.write_transform_message(self.writer, self.tf_map_vessel)
        self.num_transforms += 1


def wl_ugps_csv_to_bag(gga_path: str, hdt_path: str, acoustic_path: str, out_path: str,
                       acoustic_bias: tuple[float, ...]):
    # Create a bag and open it for writing (append is not supported)
    writer = rosbag2_py.SequentialWriter()
    storage_options = rosbag2_py.StorageOptions(uri=out_path, storage_id='sqlite3')
    converter_options = rosbag2_py.ConverterOptions('', '')
    writer.open(storage_options, converter_options)

    # Create the tf topic
    util.create_topic('tf', writer, 'tf2_msgs/msg/TFMessage')

    # Create our state object
    state = State(writer, acoustic_bias)

    # Open the csv files we need
    gga_csv = open(gga_path, 'r', newline='')
    hdt_csv = open(hdt_path, 'r', newline='')
    acoustic_csv = open(acoustic_path, 'r', newline='')

    gga_reader = csv.DictReader(gga_csv, delimiter=',')
    hdt_reader = csv.DictReader(hdt_csv, delimiter=',')
    acoustic_reader = csv.DictReader(acoustic_csv, delimiter=',')

    # Get the first row from each csv file
    gga_row = next(gga_reader)
    hdt_row = next(hdt_reader)
    acoustic_row = next(acoustic_reader)

    # Merging the 3 csv files into a single bag. For each iteration find the earliest row, pop it and process it.
    try:
        while True:
            gga_s = float(gga_row['timestamp'])
            hdt_s = float(hdt_row['timestamp'])
            acoustic_s = float(acoustic_row['timestamp'])

            if gga_s < hdt_s and gga_s < acoustic_s:
                state.recv_gga(gga_row)
                gga_row = next(gga_reader)
            elif hdt_s < gga_s and hdt_s < acoustic_s:
                state.recv_hdt(hdt_row)
                hdt_row = next(hdt_reader)
            else:
                state.recv_acoustic(acoustic_row)
                acoustic_row = next(acoustic_reader)

    except StopIteration:
        print('Ran out of something, stopping')

    print(f'wrote {state.num_transforms} transforms')


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, description=__doc__)

    # Future: provide a path, and this script will search for the cvs files in that path
    parser.add_argument('path')
    parser.add_argument('gga_filename')
    parser.add_argument('hdt_filename')
    parser.add_argument('acoustic_filename')

    # This removes the bias added by the g2 box:
    parser.add_argument('--acoustic-bias', type=str, default='-1.273,1.57,0.377')

    args = parser.parse_args()

    acoustic_bias = tuple(map(float, args.acoustic_bias.split(',')))
    assert len(acoustic_bias) == 3

    gga_path = args.path + '/' + args.gga_filename
    hdt_path = args.path + '/' + args.hdt_filename
    acoustic_path = args.path + '/' + args.acoustic_filename

    wl_ugps_csv_to_bag(gga_path, hdt_path, acoustic_path, '/tmp/wl_ugps_csv_bag', acoustic_bias)


if __name__ == '__main__':
    main()
